<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BlackieDM</title>
    <description>缘来缘去缘如风
</description>
    <link>http://blackiedm.github.io//</link>
    <atom:link href="http://blackiedm.github.io//feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 18 Feb 2016 14:58:36 +0800</pubDate>
    <lastBuildDate>Thu, 18 Feb 2016 14:58:36 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>内存泄漏－实践篇</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;知识点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;shallow heap:对象自身内存大小&lt;/li&gt;
  &lt;li&gt;retained heap:对象自身及对象所有引用的内存之和,即gc时,回收该对象后一共释放的内存&lt;/li&gt;
  &lt;li&gt;gcRoot:垃圾回收器对象&lt;/li&gt;
  &lt;li&gt;strong reference:强引用,即使是内存不够时,垃圾回收器不会回收该对象&lt;/li&gt;
  &lt;li&gt;soft reference:软引用, 在内存足够时垃圾回收器不会回收该对象,当内存不够时会回收该对象&lt;/li&gt;
  &lt;li&gt;weak reference:弱引用,当不再引用时,立即回收    &lt;/li&gt;
  &lt;li&gt;ThreadLocal:通过为每个线程提供独立的变量副本解决变量并发访问的问题&lt;/li&gt;
  &lt;li&gt;线程同步机制:通过对象的锁机制保证同一时间只有一个线程访问变量&lt;/li&gt;
  &lt;li&gt;Memory Monitor:用于观察整个应用内存变化&lt;/li&gt;
  &lt;li&gt;MAT:堆内存分析工具&lt;/li&gt;
  &lt;li&gt;Dominator tree: 列出内存中所有对象,及他们所占用的内存大小&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;步骤&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;发现泄露现象&lt;/li&gt;
  &lt;li&gt;定位问题&lt;/li&gt;
  &lt;li&gt;解决问题&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;具体&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;发现泄露现象&lt;/strong&gt;:通过&lt;code&gt;Android studio&lt;/code&gt; 的&lt;code&gt;Memory Monitor&lt;/code&gt; 观察应用内存变化.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;具体操作&lt;/strong&gt;:启动应用(此时占用内存达100M左右),退出应用, 同时使用GC操作(此时占用内存没有明显变化,猜想这里发生内存泄露),再次启动应用(此时占用内存从100M升到160M,再次证实应用存在内存泄露)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定位问题&lt;/strong&gt;:启动应用并退出应用,此时应用还在运行,获取内存快照&lt;code&gt;Dump java heap&lt;/code&gt;,此时生成hprof文件(位置在AS左侧栏&lt;code&gt;Captures-&amp;gt;Heap Snapshot&lt;/code&gt;下),右键生成标准的hprof文件,使用MAT打开,然后打开&lt;code&gt;dominator tree&lt;/code&gt;,如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/article_images/2016-02-18-memory_leak/memory_leak_1.png&quot; alt=&quot;figure 0&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有上面截图可知,&lt;code&gt;PercentRelativeLayout&lt;/code&gt;的&lt;code&gt;retained Heap&lt;/code&gt;的百分百超过50%,猜想内存泄露可能是它.
这时找到它到gcRoot的路径:右键点击&lt;code&gt;Path To Gc Roots -&amp;gt; 除了软引用和弱引用&lt;/code&gt;,截图如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/article_images/2016-02-18-memory_leak/memory_leak_2.png&quot; alt=&quot;figure 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;角标左下有个小黄点的就是&lt;code&gt;gcRoot&lt;/code&gt;,此时可初步判断是&lt;code&gt;InputMethodManager&lt;/code&gt;的调用和&lt;code&gt;View3Pagers&lt;/code&gt;下的线程池&lt;code&gt;excutor&lt;/code&gt;的线程出了问题.
当然MAT此外还提供了&lt;code&gt;Leak Supspects&lt;/code&gt;直接帮你分析出内存泄露的对象,如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/article_images/2016-02-18-memory_leak/memory_leak_3.png&quot; alt=&quot;figure 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第一个问题也是&lt;code&gt;PercentRelativeLayout&lt;/code&gt;所占内存最多(证明第一次猜想),点击详情查看,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/article_images/2016-02-18-memory_leak/memory_leak_4.png&quot; alt=&quot;figure 3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MAT直接帮你定位到引起内需泄露的对象&lt;code&gt;InputMethodManager&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;知道了问题所在,那就赶紧解决它吧.&lt;/p&gt;
</description>
        <pubDate>Thu, 18 Feb 2016 19:29:25 +0800</pubDate>
        <link>http://blackiedm.github.io//android/2016/02/18/memory-leak.html</link>
        <guid isPermaLink="true">http://blackiedm.github.io//android/2016/02/18/memory-leak.html</guid>
        
        <category>android</category>
        
        
        <category>android</category>
        
      </item>
    
  </channel>
</rss>
